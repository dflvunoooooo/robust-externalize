\documentclass[a4paper,doc2]{ltxdoc} % doc2 is needed to force the old version, or links get colored in a weird red way even with hidelinks. https://github.com/latex3/latex2e/issues/822

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Warning: if you compile and get:
%% ERROR: Argument of \tikz@lib@matrix@with@options has an extra }.
%% make sure to fix catcodes around it as | is given a different meaning in ltxdoc.

\usepackage{amsmath}
\usepackage[margin=3cm]{geometry}
\usepackage{calc}
\usepackage{tikz}
\usetikzlibrary{shadows,fit}
% \usetikzlibrary fails because file is not in current directory, lazy to setup TEXINPUTS
\makeatletter
  \input{../robust-externalize.sty}
\makeatother
% Loads the great package that produces tikz-like manual (see also tikzcd for examples)
\input{pgfmanual-en-macros.tex} % Is supposed to be included in recent TeX distributions, but I get errors...
\usepackage{makeidx} % Produces an index of commands.
\makeindex % Useful or not index will be created
\usepackage{alertmessage} % For warning, info...
\newcommand{\mylink}[2]{\href{#1}{#2}\footnote{\url{#1}}}
\usepackage{verbatim}
\usepackage{mathtools}
\usepackage{float} %figure inside minipage
\usepackage{listings}
\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}


\begin{document}
%%% Title: thanks tikzcd for the styling
\begin{center}
  \vspace*{1em} % Thanks tikzcd
  \tikz\node[scale=1.2]{%
    \color{gray}\Huge\ttfamily \char`\{\raisebox{.09em}{\textcolor{red!75!black}{robust\raisebox{-0.1em}{-}externalize}}\char`\}};

  \vspace{0.5em}
  {\Large\bfseries Cache anything (\tikzname, python…),\\in a robust, efficient and pure way.}

  \vspace{1em}
  {Léo Colisson \quad Version 2023/03/22-unstable}\\[3mm]
  {\href{https://github.com/leo-colisson/robust-externalize}{\texttt{github.com/leo-colisson/robust-externalize}}}
\end{center}

\tableofcontents

\bigskip

\textbf{WARNING: This library is very young and has not been tested extensively. Even if we try to stay backward compatible, the only guaranteed way to be immune to changes is to copy/paste the library in your main project folder.}

\section{Introduction}

\subsection{Why do I need to cache (a.k.a. externalize) parts of my document?}

One often wants to cache (i.e.\ store pre-compiled parts of the document, like figures) operations that are long to do: For instance, TikZ is great, but TikZ figures often takes time to compile (it can easily take a few seconds per picture). This can become really annoying with documents containing many pictures, as the compilation can take multiple minutes: for instance my thesis needed roughly 30mn to compile as it contains many tiny figures, and LaTeX needs to compile the document multiple times before converging to the final result. But even on much smaller documents you can easily reach a few minutes of compilation, which is not only high to get a useful feedback in real time, but worse, when using online \LaTeX{} providers (e.g. overleaf), this can be a real pain as you are unable to process your document due to timeouts.

Similarly, you might want to cache the result of some codes, for instance a text or an image generated via python and matplotlib, without manually compiling them externally.

\subsection{Why not using \tikzname{}'s externalize library?}

\tikzname{} has an externalize library to pre-compile these images on the first run. Even if this library is quite simple to use, it has multiple issues:
\begin{itemize}
\item If you add a picture before existing pre-compiled pictures, the pictures that are placed after will be recompiled from scratch. This can be mitigated by manually adding a different prefix to each picture, but it is highly not practical to use.
\item To compile each picture, TikZ's externalize library reads the document's preambule and needs to process (quickly) the whole document. In large documents (or in documents relying on many packages), this can result in a significant loading time, sometimes much bigger than the time to compile the document without the externalize library: for instance, if the document takes 10 seconds to be processed, and if you have 200 pictures that take 1s each to be compiled, the first compilation with the TikZ's externalize library will take roughly half an hour instead of 3mn without the library. And if you add a single picture at the beginning of the document… you need to restart everything from scratch. For these reasons, I was not even able to compile my thesis with TikZ's external library in a reasonable time.
\item  If two pictures share the same code, it will be compiled twice
\item Little purity is enforced: if a macro changes before a pre-compiled picture that uses this macro, the figure will not be updated. This can result in different documents depending on whether the cache is cleared or not.
\item As far as I know, it is made for TikZ picture mostly, and is not really made for inserting other stuff, like matplotlib images generated from python etc...
\item According to some maintainers of TikZ, ``\mylink{https://github.com/pgf-tikz/pgf/issues/758}{the code of the externalization library is mostly unreadable gibberish}'', and therefore most of the above issues are unlikely to be solved in a foreseable future.
\end{itemize}

\subsection{FAQ}

\paragraph{What is not supported?}

We don't support (yet) overlays, remember picture, and you can't use (yet) cross-references inside your images (at least not without further hacks). See other limitations and known bugs at the end of this documentation. Note that this library is quite young, so expect untested things.

\paragraph{Do I need to compile using -shell-escape?}

Since we need to compile the images via an external command, the simpler option is to add the argument |-shell-escape| to let the library run the  compilation command automatically (this is also the case of \tikzname's externalize library). However, people worried by security issues of |-shell-escape| (that allows arbitrary code execution if you don't trust the \LaTeX{} code) might be interested by these facts:
\begin{itemize}
\item If images are all already cached, you don't need to enable \texttt{-shell-escape}.
\item You can choose not to compile non-cached content, and display a dummy content instead until you choose to compile them.
\item You can compile manually the images: all the commands that are left to be executed are listed in \texttt{robExt-compile-missing-figures.sh} and you can just run them, either with \texttt{bash robExt-compile-missing-figures.sh} or by typing them manually (most of the time it's only a matter of running \texttt{pdflatex somefile.tex}).
\end{itemize}


\paragraph{Is it working on overleaf?}

Yes: overleaf automatically compiles documents with |-shell-escape|, so nothing special needs to be done there (of course, if you use this library to run some code, the programming language might not be available, but I heard that python is installed on overleaf servers for instance, even if this needs to be doubled checked). If the first compilation of the document to cache images times out, you can just repeat this operation multiple times until all images are cached.

\paragraph{Do you have some benchmarks?}

On an early draft of a small paper containing 76 small tikz-cd based pictures (from my other zx-calculus library), we measured:
\begin{itemize}
\item 35 seconds for a normal compilation without externalization
\item 75 seconds for the first compilation with this library
\item 2.4 seconds for the next runs
\end{itemize}
So during the first compilation, we lost a x2 factor (roughly an additional time of .5 seconds per picture coming from the time to start \LaTeX{}, it seems like on average a picture takes .5 seconds to be built in my benchmark), but then we have a speedup of x15 (2.43s instead of 34.63s) for all subsequent runs. And I expect this to be even higher with more pictures and more complex documents.

\paragraph{Can I use version-control to keep the cached files in my repository?} Sure, each cached figure is stored in a few files (typically one pdf and one \LaTeX{} file, plus the source) having the same prefix (the hash), avoiding collision between runs. Just commit these files and you are good to go.

\paragraph{Can you deal with baseline position ?} Yes, the depth of the box is automatically computed and used to include the figure by default.

\paragraph{How is purity enforced?} Purity is the property that if you remove the cached files and recompile your document, you should end-up with the same output. To enforce purity, we compute the hash of the final program, including the compilation command and the dependency files used for instance in |\input{include.tex}| (unless you prefer not to, for instance to keep parts of the process impure for efficiency reasons), and put the code in a file named based on this hash. Then we compile it if it has not been used before, and include the output. Changing a single character in the file, the tracked dependencies, or the compilation command will lead to a new hash, and therefore to a new generated picture.

\paragraph{Can I extend it easily?} We tried to take a quite modular approach in order to allow easy extensions. Internally, to support a new cache scheme, we only expect a string containing the program (possibly produced using a template), a list of dependencies, a command to compile this program (e.g. producing a pdf and possibly a tex file with the properties (depth…) of the pdf), and a command to load the result of the compilation into the final document (called after loading the previously mentioned optional tex file). Thanks to pgfkeys, it is then possible to create simple pre-made settings to automatically apply when needed.

\section{Quickstart}

\subsection{Installation}

To install the library, just copy the |robust-externalize.sty| file into the root of the project. Then, load the library using:\\

|\usepackage{robust-externalize}|

\subsection{Usage}

\subsubsection{For \LaTeX{} based content}

% In theory, if you only care about \tikzname's picture (and if you are not afraid of breaking figures using |overlay| and |remember pictures|, possibly defined by other packages), you can just do:

% \begin{codeexample}[width=0pt]
% %% We override the default tikzpicture environment
% %% to externalize all pictures  
% \robExtExternalizeAllTikzpictures

% \begin{tikzpicture}[baseline,anchor=base]
%   \node[draw,rounded corners,fill=pink!60]{Hello World!};
% \end{tikzpicture}
% \end{codeexample}

% \noindent and all tikzpictures created using |\begin{tikzpicture}...| will be ``externalized''. However, by default the \LaTeX{} template used to compile these pictures is empty, so you will quickly want to populate the template (for instance to load packages, define custom macros possibly shared with the main document etc.). So let's step back and see how we can define an arbitrary template.

% If you want to compile a \LaTeX{} code, say a \tikzname{} picture, you first need to define the \LaTeX{} template that will wrap all your code\footnote{While you could use the same preambule as the main project, for instance using a shared \texttt{\textbackslash input\{input.tex\}} file, this is not recommended as it will not only be longer to load (some packages are useless to build your average tikzpictures), but it also harms purity or efficiency: if you choose to track this common input (i.e.\ dependency), then it will recompile the pictures every time you change \texttt{input.tex}, and if you don't track this dependency, then you might skip a needed recompilation leading to a different outcome after invalidating the cache.}. Because you might want to mix different templates in a document (e.g.\ for tikz pictures, matplotlib python code, tikz-cd or zx diagrams…), we like to define them into a preset that is just a set of configuration options\footnote{Internally this is just a pgfkeys style, if you don't want to define presets, you can just write the configuration outside of the preset… but this is not recommended, except for some specific configuration options like \texttt{disable externalization} that you way want to apply globally.}). For instance to create a basic preset called |presetTikz|, use:

% \begin{codeexample}[width=0pt]
%   \robExtConfigure{%
%     presetTikz/.style={
%       % We define the code that wraps all our figures
%       defineTemplate={
%         \documentclass{standalone} % standalone ensures that the pdf output size matches the content
%         \usepackage{tikz} % Loads any package you need to compile your pictures
%         % You can define macros, just make sure to double the number of sharps
%         % as otherwise they will be understood as options of the preset.
%         \def\sayHello##1{Hello ##1}
%         \input{input_externalize.tex} % you can put in this file regular LaTeX code to share with the main document
%         \begin{document}%
%         \robExtMainContent% This macro will be replaced with (notably) the code for the figure
%         \end{document}
%       },
%       % The dependency files needed to compile the file
%       % (included when computing the hash). Separate them with commas.
%       dependencies={input_externalize.tex},
%     },
%   }
% \end{codeexample}
% % For the example to work:
% \robExtConfigure{%
%   presetTikz/.style={
%     % We define the code that wraps all our figures
%     defineTemplate={
%       \documentclass{standalone} % standalone ensures that the pdf output size matches the content
%       \usepackage{tikz} % Loads any package you need to compile your pictures
%       % You can define macros, just make sure to double the number of sharps
%       % as otherwise they will be understood as options of the preset.
%       \def\sayHello##1{Hello ##1}
%       \begin{document}%
%       \robExtMainContent% This macro will be replaced with (notably) the code for the figure
%       \end{document}
%     },
%     % The dependency files needed to compile the file
%     % (included when computing the hash). Separate them with commas.
%     dependencies={input_externalize.tex},
%   },
% }

% (see the comments for details)

% Then, if needed, create the dependency files, and use this preset as follows in your code:

% \begin{codeexample}[width=0pt]
% See that the baseline is respected %
% \begin{robExtern}{presetTikz}%
%   \begin{tikzpicture}[baseline,anchor=base]%
%     \node[draw,rounded corners,fill=pink!60]{\sayHello{World}!};
%   \end{tikzpicture}
% \end{robExtern}
% \end{codeexample}

% Note that one might be tempted to move |\begin{tikzpicture}| inside the template to save a bit of typing. However, our library is actually replacing |\robExtMainContent| with the content wrapped around some code\footnote{Basically creating a box in order to compute the depth of the content, and write it to a tex file to use for later.} that need to wrap the whole content. While we provide other macros that don't add this wrapping code\footnote{But then we need to manually add this box if we want to compute the appropriate depth, and we will need to redefine the command to disable externalization.}, it is actually simpler, more configurable, and more typing-friendly, to define an environment that automatically picks the right preset and adds |\begin{tikzpicture}| automatically for us:

% \begin{codeexample}[width=0pt]
%   \DeclareDocumentEnvironment{mytikzpicture}{O{}O{}b}{% = 2 optional arguments + the body (b), cf xparse
%     \begin{robExtern}{presetTikz,#2}%
%       \begin{tikzpicture}[#1]%
%         #3
%       \end{tikzpicture}%
%     \end{robExtern}%
%   }{}
% \end{codeexample}

% This way, in your code you can just use:
% {
%   \DeclareDocumentEnvironment{mytikzpicture}{O{}O{}b}{%
%     \begin{robExtern}{presetTikz,#2}%
%       \begin{tikzpicture}[#1]%
%         #3%
%       \end{tikzpicture}%
%     \end{robExtern}%
%   }{}
% \begin{codeexample}[width=0pt]
% See the respected baseline: %
% \begin{mytikzpicture}[baseline,anchor=base]
%   \node[draw,rounded corners,fill=pink!60]{\sayHello{World}!};
% \end{mytikzpicture}
% \end{codeexample}
% }
    
% By choosing the name |tikzpicture| instead of |mytikzpicture|, you would actually override \tikzname's macro, which should be perfectly fine if you want to externalize \tikzname's pictures by default. Because this usecase will likely be important, we actually provide a command that defines a similar environment, except that it uses a preset called |presetTikzDefault| (this style is populated with a very simple template, but you surely want to quickly override it with your own template by just creating a new preset called |presetTikzDefault|):

% \begin{codeexample}[width=0pt]
% %% We override the default tikzpicture environment:
% \robExtExternalizeAllTikzpictures

% \begin{tikzpicture}[baseline,anchor=base]
%   \node[draw,rounded corners,fill=pink!60]{Hello World!};
% \end{tikzpicture}
% \end{codeexample}

% Note that doing that could be problematic if you use packages that use |tikzpicture| relying on |remember picture| and |overlays|. For this reason it's certainly safer to just define a different |mytikzpicture| environment, or overwrite only the environment that are safe to override.

% \subsection{For non-\LaTeX{} code}

% Due to the way \LaTeX{} works, non-\LaTeX{} code can't be reliably read inside macros and some environments (e.g. align) as some characters are removed (e.g. percent symbol). For this reason, we sometimes need to separate the time where we define the code and where we insert it, and we provide therefore different commands to deal with non-\LaTeX{} code.

% The following code will name a template |pythonMatplotlib| (see how we use |ROBEXTMAINCONTENT| as a placeholder for the content), define a preset based on this template, and :

% \begin{codeexample}[width=0pt]
% % We define our python template:
% \begin{robExtNamedTemplate}[pythonMatplotlib]
% import matplotlib.pyplot as plt
% import sys
% ROBEXTMAINCONTENT
% plt.savefig(sys.argv[1]+".pdf")
% \end{robExtNamedTemplate}

% % We define a reusable preset, note that we specify the compilation command:
% \robExtConfigure{
%   presetMatplot/.style={
%     defineTemplateFromName=pythonMatplotlib,
%     set compilation command={python3 "\robExtFinalFile" "\robExtFinalPrefixedName"},
%   },
% }

% %%%%%%%%%%%%%%% Above code must be written once, below is used for any drawing

% % We draw our code:
% \begin{robExtCode}{presetMatplot,include graphics args={width=.5\linewidth}}
% year = [2014, 2015, 2016, 2017, 2018, 2019]  
% tutorial_count = [39, 117, 111, 110, 67, 29]
% plt.plot(year, tutorial_count, color="#6c3376", linewidth=3)  
% plt.xlabel('Year')  
% plt.ylabel('Number of futurestud.io Tutorials') 
% \end{robExtCode}
% \end{codeexample}

% Note that for the fundamental reasons mentioned above, the above code can't work inside a macro. If we still want to include the result in a macro, we can separate the definition of the code and its usage:
% \begin{codeexample}[width=0pt]
% % We define our python template:
% \begin{robExtNamedTemplate}[pythonMatplotlib]
% import matplotlib.pyplot as plt
% import sys
% ROBEXTMAINCONTENT
% plt.savefig(sys.argv[1]+".pdf")
% \end{robExtNamedTemplate}

% % We define a reusable preset, note that we specify the compilation command:
% \robExtConfigure{
%   presetMatplot/.style={
%     defineTemplateFromName=pythonMatplotlib,
%     set compilation command={python3 "\robExtFinalFile" "\robExtFinalPrefixedName"},
%   },
% }

% %%%%%%%%%%%%%%% Above code must be written once, below is used for any drawing

% % We define our code (implicitely giving it a default name, that can be changed
% % if multiple codes are inserted in the same macro)
% \begin{robExtNamedContent}
% year = [2014, 2015, 2016, 2017, 2018, 2019]  
% tutorial_count = [39, 117, 111, 110, 67, 29]

% plt.plot(year, tutorial_count, color="#6c3376", linewidth=3)  
% plt.xlabel('Year')  
% plt.ylabel('Number of futurestud.io Tutorials') 
% \end{robExtNamedContent}

% Inside a macro: %
% \fbox{\robExternPrev{presetMatplot,include graphics args={width=.7\linewidth}}}
% \end{codeexample}

% \subsection{Example of more advanced setup}

% We can actually do many more things. For instance, here we define another preset that compiles the document with python and matplotlib, and displays the important lines of the code above the result, inside a figure with a customizable caption:

% \begin{codeexample}[vbox]
% % Define the template. Lines with TEMPLATECODE
% % will be removed later.  
% \begin{robExtNamedTemplate}[pythonMatplotlib]
% import matplotlib.pyplot as plt # TEMPLATECODE
% import sys # TEMPLATECODE
% ROBEXTMAINCONTENT
% plt.savefig(sys.argv[1]+".pdf") # TEMPLATECODE
% \end{robExtNamedTemplate}

% \robExtConfigure{
%   % More complex version that displays both the code and the result:
%   presetMatplotAdvanced/.style={
%     /robExt/caption/.code={\gdef\mycaption{##1}}, % Provide a key to change the caption
%     defineTemplateFromName=pythonMatplotlib,
%     % This command compiles the image, and creates a file removing all the lines from the code
%     % containing TEMPLATECODE (useful not to display action of saving the file etc)
%     % This might not be portable to windows without installing cygwin, but one can replace sed
%     % with some python code doing the same for a more portable code.
%     set compilation command={python3 "\robExtFinalFile" "\robExtFinalPrefixedName" %
%       && sed '/TEMPLATECODE/d' "\robExtFinalFile" > "\robExtFinalPrefixedName.codeonly.py"},
%     custom include command={%
%       \begin{figure}[H] % Use H mostly to avoid compilation error in documentation
%         \centering
%         % Note that this will display the template around the code. We could avoid this by putting in our
%         % template a part that creates a new file whose name is the basename of the current (script) file
%         % and that contains all its code except for the template (to differentiate between template and
%         % non-template, we could add a special comment on lines to remove)
%         \verbatiminput{\robExtAddPrefixPathAndName{\robExtFinalName.codeonly.py}}
%         \includegraphics[width=.6\textwidth]{\robExtAddPrefixPathAndName{\robExtFinalName.pdf}}%
%         \caption{\mycaption}
%       \end{figure}
%     },
%   },
% }

% %%%%%%%%%%%%%%% Above code must be written once, below is used for any drawing

% \begin{robExtCode}{presetMatplotAdvanced, caption={Here is my caption for the figure}}
% year = [2014, 2015, 2016, 2017, 2018, 2019]  
% tutorial_count = [39, 117, 111, 110, 67, 29]

% plt.plot(year, tutorial_count, color="#6c3376", linewidth=3)  
% plt.xlabel('Year')  
% plt.ylabel('Number of futurestud.io Tutorials') 
% \end{robExtCode}
% \end{codeexample}

% \section{Manual}

% TODO: the example above already provide a nice view of the main functions, the |set subfolder={robustExternalize/}| option might be an important additionnal configuration option that allows you to put the cached pictures in a subfolder.

% \section{Operations on the cache}

% \subsection{Cleaning the cache}

% You might want to clean the cache. Of course you can remove all generated files, but if you want to keep the picture in use in the latest version of the document, we provide a python script (automatically generated in the root folder) to do this. Just install python3 and run:\\

% |python3 robExt-remove-old-figures.py|\\

% You will then be prompted for a confirmation after providing the list of files that will be removed.

% \subsection{Listing all figures in use}

% After the compilation of the document, a file |robExt-all-figures.txt| is created with the list of the |.tex| file of all figures used in the current document.

% \subsection{Manually compiling the figures}

% When enabling the manual mode (useful if we don't want to enable |-shell-escape|):

% |\robExtConfigure{|\\
% |  enable manual mode|\\
% |}|\\

% the library creates a file |robExt-compile-missing-figures.sh| that contains the instructions to build the figures that are not yet in the cache. On Linux (or on Windows with bash/cygwin/… installed) you can easily execute them using:

% |bash robExt-compile-missing-figures.sh|\\

% \section{TODO and known bugs:}

% \begin{itemize}
% \item Solve problem with disable externalization not working with tikz pictures
% \item See how to deal with overlays, maybe get inspired by https://github.com/sasozivanovic/memoize that seems to define a padding around the box
% \item See how to deal with label references
% \item We should create more pre-made settings, e.g. for tikz-cd, zx-calculus etc.
% \item Some commands like mkdir might not be super compatible with Windows, I need to see how to improve compatibility between OS
% \item The documentation is still sparse.
% \item I just discovered the very interesting https://github.com/sasozivanovic/memoize, not sure how it compares. The approaches seems very different.
% \item I don't think this package can directly externalize remember picture pictures.
% \end{itemize}
% % %% This picture will NOT be externalized .
% % \message{YYYYYYYYYYYYYY Next one:}
% % \begin{tikzpicture}[baseline,anchor=base][disable externalization]
% %   \node[draw,rounded corners,fill=pink!60]{Hello World!};
% % \end{tikzpicture}

\section{Documentation}

\subsection{Placeholders}

Placeholders are the main concept allowing this library to generate the content of a source file based on a template (a template will itself be a placeholder containing other placeholders). A placeholder is a special strings like |[°COLOR°IMAGE°]| inserted for instance in a template, that will be later given a value. This value will be used to replace (recursively) the placeholder in the template. For instance, if a placeholder |[°LIKES°]| contains |I like ._FRUIT_. and ._VEGETABLE_.]|, if the placeholder |._FRUIT_.]| contains |oranges| and if the placeholder |..VEGETABLE..]| contains |salad|, then evaluating |[°LIKES°]| will output |I like oranges and salad.|

% Note that the usage of underscore in only a convention, as any name can be used for the placeholder. There is however one rule to follow: the name of a placeholder should be made to avoid ambiguities when replacing the string, notably its name should not contain the name of another placeholder. For instance, if we define a placeholder called |NAME| containing |Foo| and a placeholder named |FULL°NAME| containing |Foo Bar|, then when evaluating the string |My name is FULL°NAME|, we have no way to know if the user wants to get |My name is FULL°Foo| or |My name is Foo Bar|. For this reason, \textbf{we advice users to start and end their placeholder names using, respectively, |[°| and |°]|}, while using only upper case letters and |°| inside the placeholder name (this also improves readability).

Placeholders are local variables (internally just some \LaTeX{} 3 strings). You can therefore define a placeholder in a local group surrounded by brackets |{ ... }| if you want it to have a reduced scope.

\subsubsection{Reading a placeholder}

\begin{pgfmanualentry}
  \extractcommand\getPlaceholder\opt{\oarg{new placeholder name}}\marg{name placeholder or string}\@@
  \extractcommand\getPlaceholderInResult\opt{\oarg{new placeholder name}}\marg{name placeholder or string}\@@
  \pgfmanualbody

  Get the value of a placeholder after replacing (recursively) all the inner placeholders. |\getPlaceholderInResult| puts the resulting string in a \LaTeX{} 3 string |\l_robExt_result_str|, while |\getPlaceholder| directly outputs this string. You can also put inside the argument
  any arbitrary string, allowing you, for instance, to concatenate multiple placeholders, copy a placeholder etc. Note that you will get a string, but this string will not be evaluated by \LaTeX{} (see |\evalPlaceholder| for that), for instance math will not be interpreted:
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromContent{__MY_PLACEHOLDER__}{Hello __NAME__, I am a template $\delta_n$.}
  \placeholderFromContent{__NAME__}{Alice __NICKNAME__}
  \placeholderFromContent{__NICKNAME__}{the great}
  The placeholder evaluates to:\\
  \texttt{\getPlaceholder{__MY_PLACEHOLDER__}}\\
  Combining placeholders produces:\\
  \texttt{\getPlaceholder{In ``__MY_PLACEHOLDER__'', the name is __NAME__.}}
\end{codeexample}
You can also specify the optional argument in order to additionally define a new placeholder containing the resulting string (but you might prefer to use its alias |\setPlaceholderRec| described below):
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromContent{__MY_PLACEHOLDER__}{Hello __NAME__, I am a template $\delta_n$.}
  \placeholderFromContent{__NAME__}{Alice __NICKNAME__}
  \placeholderFromContent{__NICKNAME__}{the great}
  \getPlaceholderInResult[__NEW_PLACEHOLDER__]{In ``__MY_PLACEHOLDER__'', the name is __NAME__.}
  \printAllPlaceholdersExceptDefaults
\end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \extractcommand\evalPlaceholder\marg{name placeholder or string}\@@
  \pgfmanualbody

  Evaluate the value of a placeholder after replacing (recursively) all the inner placeholders. You can also put inside any arbitrary string.
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromContent{__MY_PLACEHOLDER__}{Hello __NAME__, I am a template $\delta_n$.}
  \placeholderFromContent{__NAME__}{Alice __NICKNAME__}
  \placeholderFromContent{__NICKNAME__}{the great}
  % The placeholder evaluates to \texttt{\getPlaceholder{__MY_PLACEHOLDER__}}.
  The placeholder evaluates to:\\
  \evalPlaceholder{__MY_PLACEHOLDER__}\\
  Combining placeholders produces:\\
  \evalPlaceholder{In ``__MY_PLACEHOLDER__'', the name is __NAME__.}
\end{codeexample}
\end{pgfmanualentry}

\subsubsection{List and debug placeholders}

It can sometimes be handy to list all placeholders, print their contents etc. We list here commands that are mostly useful for debugging purposes.

\begin{pgfmanualentry}
  \extractcommand\printAllPlaceholdersExceptDefaults\opt{*}\@@
  \pgfmanualbody

  Prints the verbatim content of all defined placeholders (without performing any replacement of inner placeholders), except for the placeholders that are defined by default in this library (that we identify as they start with |__ROBEXT_|). The stared version does print the name of the placeholder defined in this library, but not their definition. This is mostly for debugging purposes.
\begin{codeexample}[width=0pt,vbox]
\placeholderFromContent{__LIKES__}{Hello __NAME__ I am a really basic template $\delta_n$.}
\placeholderFromContent{__NAME__}{Alice}    
\printAllPlaceholdersExceptDefaults
\end{codeexample}
Compare with:
\begin{codeexample}[width=0pt,vbox]
\placeholderFromContent{__LIKES__}{Hello __NAME__ I am a really basic template $\delta_n$.}
\placeholderFromContent{__NAME__}{Alice}    
\printAllPlaceholdersExceptDefaults*
\end{codeexample}

\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractcommand\printAllPlaceholders\@@
  \pgfmanualbody

  Prints the verbatim content of all defined placeholders (without performing any replacement of inner placeholders), including the placeholders that are defined by default in this library. This is mostly for debugging purposes. Here is the result of |\printAllPlaceholders|:

  \printAllPlaceholders
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \extractcommand\printPlaceholderNoReplacement\marg{name placeholder}\@@
  \pgfmanualbody

  Prints the verbatim content of a given placeholder, without evaluating it and \textbf{without replacing inner placeholders: it is used mostly for debugging purposes} and will be used in this documentation to display the content of the placeholder for educational purposes. The stared version prints it inline.
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromContent{__LIKES__}{Hello NAME I am a really basic template $\delta_n$.}
  \placeholderFromContent{NAME}{Alice}    
  The (unexpanded) template contains \printPlaceholderNoReplacement{__LIKES__}.\\
  The (unexpanded) template contains \printPlaceholderNoReplacement*{__LIKES__}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractcommand\evalPlaceholderNoReplacement\marg{name placeholder}\@@
  \pgfmanualbody

  Evaluates the content of a given placeholder as a \LaTeX{} code, \textbf{without replacing the placeholders contained inside (mostly used for debugging purposes).}
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromContent{__LIKES__}{Hello NAME I am a really basic template $\delta_n$.}
  \placeholderFromContent{NAME}{Alice}
  The (unexpanded) template evaluates to ``\evalPlaceholderNoReplacement{__LIKES__}''.
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractcommand\getPlaceholderNoReplacement\marg{name placeholder}\@@
  \pgfmanualbody

  Like |\evalPlaceholderNoReplacement| except that it only outputs the string without evaluating the macros inside.
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromContent{__LIKES__}{Hello NAME I am a really basic template $\delta_n$.}
  \placeholderFromContent{NAME}{Alice}
  The (unexpanded) template contains \texttt{\getPlaceholderNoReplacement{__LIKES__}}
\end{codeexample}
\end{pgfmanualentry}

\subsubsection{Setting a value to a placeholder}


\begin{pgfmanualentry}
  \extractcommand\placeholderFromContent\marg{name placeholder}\marg{content placeholder}\@@
  \extractcommand\setPlaceholder\marg{name placeholder}\marg{content placeholder}\@@
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set placeholder=\marg{name placeholder}\marg{content placeholder}\@nil
  \extractkey/robExt/set placeholder from content=\marg{name placeholder}\marg{content placeholder}\@nil
  \makeatother%
  \pgfmanualbody

  |\placeholderFromContent| (and its alias |\setPlaceholder| and its equivalent pgf styles |/robExt/set placeholder| and |/robExt/set placeholder from content|) is useful to set a value to a given placeholder.
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromContent{__LIKES__}{Hello I am a basic template with math $\delta_n$ and macros \hello}
  The (unexpanded) template contains \printPlaceholderNoReplacement{__LIKES__} and %
  after evaluation and setting the value of hello,%
  \def\hello{Hello my friend!}%
  you get ``\evalPlaceholder{__LIKES__}''.
\end{codeexample}
  As you can see, \textbf{the precise content is not exactly identical to the original string}: \LaTeX{} comments are removed, spaces are added after macros, some newlines are removed etc. While this is usually not an issue when dealing with \LaTeX{} code, it causes some troubles when dealing with non-\LaTeX{} code. For this reason, we define \textbf{other commands} (see for instance |PlaceholderFromCode| below) that can accept verbatim content; the downside being that \LaTeX{} forbids usage of these verbatim commands inside other macros, so you should always define them at the top level (this seems to be fundamental to how \LaTeX{} works, as any input to a macro gets interpreted first as a \LaTeX{} string, losing all comments for instance). Note that this is not as restrictive as it may sound, as it is always possible to define the needed placeholders before any macro, while using them inside the macro, possibly combining them with other placeholders (defined either before or inside the macro).
\end{pgfmanualentry}

But before seeing how to define placeholder containing arbitrary code, let us first see how we can define a placeholder recursively, by giving it a value based on its previous value (useful for instance in order to add stuff to it):

\begin{pgfmanualentry}
  \extractcommand\setPlaceholderRec\marg{new placeholder}\marg{content with placeholder}\@@
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set placeholder rec=\marg{name placeholder}\marg{content placeholder}\@nil
  \makeatother%
  \pgfmanualbody

  |\setPlaceholderRec{foo}{bar}| is actually an alias for |\getPlaceholderInResult[foo]{bar}|. Note that contrary to |\setPlaceholder|, it recursively replaces all inner placeholders. This is particularly useful to add stuff to an existing (or not) placeholder:
\begin{codeexample}[width=0pt,vbox]
\setPlaceholderRec{__MY_COMMAND__}{pdflatex}
\setPlaceholderRec{__MY_COMMAND__}{__MY_COMMAND__ myfile}
\printAllPlaceholdersExceptDefaults
\end{codeexample}
Not that the if the placeholder content contains at the end the placeholder name, we will automatically remove it to avoid infinite recursion at evaluation time. This has the benefit that you can add something to a placeholder even if this placeholder does not exists yet (in which case it will be understood as the empty string):
\begin{codeexample}[width=0pt,vbox]
\setPlaceholderRec{__COMMAND_ARGS__}{__COMMAND_ARGS__ -l}
\setPlaceholderRec{__COMMAND_ARGS__}{__COMMAND_ARGS__ -s}
\printAllPlaceholdersExceptDefaults
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractcommand\evalPlaceholderInplace\marg{name placeholder}\@@
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/eval placeholder inplace=\marg{name placeholder}\@nil
  \makeatother%
  \pgfmanualbody
  This command will update (inplace) the content of a macro by first replacing recursively the placeholders, and finally by expanding the  \LaTeX{} macros.
\begin{codeexample}[width=0pt,vbox]
\def\mymacro{Initial value}    
\placeholderFromContent{__MACRO_NOT_EVALUATED__}{\mymacro}
\placeholderFromContent{__MACRO_EVALUATED__}{\mymacro}
\evalPlaceholderInplace{__MACRO_EVALUATED__}
\printAllPlaceholdersExceptDefaults
\def\mymacro{Final value}    
Compare \evalPlaceholder{__MACRO_EVALUATED__} and \evalPlaceholder{__MACRO_NOT_EVALUATED__}.
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set placeholder eval=\marg{name placeholder}\marg{content placeholder}\@nil
  \makeatother%
  \pgfmanualbody
  Alias for |\setPlaceholderRec{#1}{#2}\evalPlaceholderInplace{#1}|: set and evaluate recursively the placeholders and macros.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractenvironement{PlaceholderFromCode}\marg{name placeholder}\@@
  \pgfmanualbody

  This environment is useful to set a verbatim value to a given placeholder: the advantage is that you can put inside any code, including \LaTeX{} comments, the downside is that you cannot use it inside macros and some environments (so you typically define it before the macros and call it inside, possibly inserting other simpler placeholders inside that you can define inside the macros).
% \begin{codeexample}[width=0pt,vbox]
%   \placeholderFromContent{__PYTHON_CODE__}{}
%   The (unexpanded) template contains \printPlaceholderNoReplacement{__LIKES__} and %
%   after evaluation (no replacement), you get ``\evalPlaceholderNoReplacement{__LIKES__}''.
% \end{codeexample}

\begin{codeexample}[width=0pt,vbox]
\begin{PlaceholderFromCode}{__PYTHON_CODE__}
def my_function(b): # this is a python code
    c = {}
    d[42] = 0
    return b
\end{PlaceholderFromCode}
\printAllPlaceholdersExceptDefaults
\end{codeexample}


Note that |PlaceholderFromCode| should not be used inside other macros or inside some environments (notably the ones that need to evaluate the body of the environment, e.g. using |+b| argument or |environ|) as verbatim content is parsed first by the macro, meaning that some characters might be changed or removed. For instance, any percent character would be considered as a comment, removing the rest of the line. However, this should not be be problem if you use it outside of any macro or environment, or if you load it from a file. For instance this code:
\begin{verbatim}
\begin{PlaceholderFromCode}{__PYTHON_CODE__}
def my_function(b): # this is a python code
    c = {}
    d[42] = 0
    return b % 2
\end{PlaceholderFromCode}
\printAllPlaceholdersExceptDefaults
\end{verbatim}
would produce:

{
\begin{PlaceholderFromCode}{__PYTHON_CODE__}
def my_function(b): # this is a python code
    c = {}
    d[42] = 0
    return b % 2
\end{PlaceholderFromCode}
\begin{codeexample}[width=0pt,vbox]
\printAllPlaceholdersExceptDefaults
\end{codeexample}
}
Note that of course, you can define a placeholder before a macro and call it inside (explaining how we can generate this documentation).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractcommand\placeholderPathFromFilename\marg{name placeholder}\marg{filename}\@@
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set placeholder path from filename=\marg{name placeholder}\marg{filename}\@nil
  \makeatother%
  \pgfmanualbody

  |\placeholderPathFromFilename{__MYLIB__}{mylib.py}| will copy |mylib.py| in the cache (setting its hash depending on its content), and set the content of the placeholder |__MYLIB__| to the \textbf{path} of the library in the cache. Note that the path is relative to the cache folder (it is easier to use for instance if you want to call this library from a code already in the cache).
\begin{codeexample}[width=0pt,vbox]
  \placeholderPathFromFilename{__MYLIB__}{mylib.py}
  \printAllPlaceholdersExceptDefaults
  You can also get the path relative to the root folder:\\
  \robExtAddPrefixPath{\getPlaceholderNoReplacement{__MYLIB__}}
\end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \extractcommand\placeholderFromFileContent\marg{name placeholder}\marg{filename}\@@
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set placeholder from file content=\marg{name placeholder}\marg{filename}\@nil
  \makeatother%
  \pgfmanualbody

  |\placeholderFromFileContent{__MYLIB__}{mylib.py}| will set the content of the placeholder |__MYLIB__| to the content of |mylib.py|.
\begin{codeexample}[width=0pt,vbox]
  \placeholderFromFileContent{__MYLIB__}{mylib.py}
  \printAllPlaceholdersExceptDefaults
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractcommand\placeholderPathFromContent\marg{name placeholder}\opt{\oarg{suffix}}\marg{content}\@@
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set placeholder path from content=\marg{name placeholder}\marg{suffix}\marg{content}\@nil
  \makeatother%
  \pgfmanualbody

  |\placeholderPathFromContent{__MYLIB__}{some content}| will copy |some content| in a file in the cache (setting its hash depending on its content, the filename will end with |suffix| that defaults to |.tex|), and set the content of the placeholder |__MYLIB__| to the \textbf{path} of the file in the cache. Note that the path is relative to the cache folder (it is easier to use for instance if you want to call this library from a code already in the cache).
\begin{codeexample}[width=0pt,vbox]
  \placeholderPathFromContent{__MYLIB__}[.py]{some contents b}
  \printAllPlaceholdersExceptDefaults
  You can also get the path relative to the root folder:\\
  \robExtAddPrefixPath{\getPlaceholderNoReplacement{__MYLIB__}}\\
  As a sanity check, this file contains
  \verbatiminput{\robExtAddPrefixPath{\getPlaceholderNoReplacement{__MYLIB__}}}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \extractenvironement{PlaceholderPathFromCode}\opt{\oarg{suffix}}\marg{name placeholder}\@@
  \pgfmanualbody

  This environment is similar to |\placeholderPathFromContent| except that it accepts verbatim code (therefore \LaTeX{} comments, newlines etc. will not be removed). However, due to \LaTeX{} limitations, this environment cannot be used inside macros or some environments, or this property will not be preserved.
  For instance, if you create your placeholder using:
\begin{verbatim}
\begin{PlaceholderPathFromCode}[.py]{__MYLIB__}
def my_function(b): # this is a python code
    c = {}
    d[42] = 0
    return b % 2
\end{PlaceholderPathFromCode}
\end{verbatim}
%% The code cannot be placed inside codeexample as it needs to parse the body:
\begin{PlaceholderPathFromCode}[.py]{__MYLIB__}
def my_function(b): # this is a python code
    c = {}
    d[42] = 0
    return b % 2
\end{PlaceholderPathFromCode}
You can then use it like:
\begin{codeexample}[width=0pt,vbox]
\printAllPlaceholdersExceptDefaults
You can also get the path relative to the root folder:\\
\robExtAddPrefixPath{\getPlaceholderNoReplacement{__MYLIB__}}\\
As a sanity check, this file contains
\verbatiminput{\robExtAddPrefixPath{\getPlaceholderNoReplacement{__MYLIB__}}}
\end{codeexample}
\end{pgfmanualentry}

\subsection{Caching a content}

\subsubsection{Basics}

\begin{pgfmanualentry}
  \extractcommand\cacheMe\opt{\oarg{preset style}}\marg{content to cache}\@@
  \extractenvironement{CacheMe}\marg{preset style}\@@
  \pgfmanualbody
  This command (and its environment alias) is the main entry point if you want to cache the result of a file. The preset style is a pgfkeys-based style that is used to configure the template that is used, the compilation command, and more. You can either inline the style, or use some presets that configure the style automatically. After evaluating the style, the placeholders |__ROBEXT_TEMPLATE__| (containing the content of the file) and |__ROBEXT_COMPILATION_COMMAND__| (containing the compilation command run in the cache folder, that can use other placeholders internally like |__ROBEXT_SOURCE_FILE__| to get the path to the source file) should be set. Note that we provide some basic styles that allow settings these placeholders easily. See \cref{sec:placeholders} for a list of existing placeholders and presets. The placeholder |__ROBEXT_MAIN_CONTENT__| will automatically be set by this command (or environment) so that it equals the content of the second argument (or the body of the environment). This style can also configure the command to use to include the file and more. By default it will insert the compiled PDF, making sure that the depth is respected (internally, we read the depth from an aux file created by our \LaTeX{} preset), but you can easily change it to anything you like.

  For an educational purpose, we write here an example that does not exploit any preset. In practice, we recommend however to use our presets, or to define new presets based on our presets (see below for examples).
\begin{codeexample}[width=0pt,vbox]
\begin{CacheMe}{set template={
      \documentclass{standalone}
      \begin{document}
      __ROBEXT_MAIN_CONTENT__
      \end{document}
    },
    set compilation command={pdflatex -shell-escape -halt-on-error "__ROBEXT_SOURCE_FILE__"},
    custom include command={%
      \includegraphics[width=4cm,angle=45]{\robExtAddPrefixPathAndName{\robExtFinalHash.pdf}}%
    },
  }
This content is cached $\delta$.    
\end{CacheMe}
\end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \extractenvironement{CacheMeCode}\marg{preset style}\@@
  \pgfmanualbody
  Like |CacheMe|, except that the code is read verbatim by \LaTeX{}. This way, you can put non-\LaTeX{} code inside safely, but you will not be able to use it inside a macro or some environments that read their body.
\begin{codeexample}[width=0pt,vbox]
\end{codeexample}
\end{pgfmanualentry}

% \begin{PlaceholderFromCode}{__MY_MATHPLOTLIB_TEMPLATE__}
% import matplotlib.pyplot as plt
% import sys
% __ROBEXT_MAIN_CONTENT__
% plt.savefig("__ROBEXT_OUTPUT_PDF__")  
% \end{PlaceholderFromCode}

% \begin{CacheMeCode}{set template={__MY_MATHPLOTLIB_TEMPLATE__}
%     set compilation command={python "__ROBEXT_SOURCE_FILE__"},
%     custom include command={%
%       \includegraphics[width=4cm,angle=45]{\robExtAddPrefixPathAndName{\robExtFinalHash.pdf}}%
%     },
%   }
% year = [2014, 2015, 2016, 2017, 2018, 2019]  
% tutorial_count = [39, 117, 111, 110, 67, 29]
% plt.plot(year, tutorial_count, color="#6c3376", linewidth=3)  
% plt.xlabel('Year')  
% plt.ylabel('Number of futurestud.io Tutorials') 
% \end{CacheMeCode}

\begin{pgfmanualentry}
  \extractcommand\robExtConfigure\marg{preset style}\@@
  \pgfmanualbody
  You can then create your own style (or preset) in |\robExtConfigure| (that is basically an alias for |\pgfkeys{/robExt/.cd,#1}|) containing your template, add your own placeholders and commands to configure them etc.

\begin{codeexample}[width=0pt,vbox]
%% Define your presets once:
\robExtConfigure{%
  my latex preset/.style={
    %% Create a default value for my new placeholders:
    set placeholder={__MY_COLOR__}{red},
    set placeholder={__MY_ANGLE__}{45},
    % We can also create custom commands to "hide" the notion of placeholder
    set my angle/.style={
      set placeholder={__MY_ANGLE__}{##1}
    },
    set template={
      \documentclass{standalone}
      \usepackage{xcolor}
      \begin{document}
      \color{__MY_COLOR__}__ROBEXT_MAIN_CONTENT__
      \end{document}
    },
    set compilation command={pdflatex -shell-escape -halt-on-error "__ROBEXT_SOURCE_FILE__"},
    custom include command={%
      % The include command is a regular LaTeX command, but using
      % \evalPlaceholder avoids the need to play with expandafter, getPlaceholder etc...
      \evalPlaceholder{% 
        \includegraphics[width=4cm,angle=__MY_ANGLE__,origin=c]{%
          \robExtAddPrefixPathAndName{\robExtFinalHash.pdf}%
        }%
      }%
    },
  },
}

% Reuse them later...
\begin{CacheMe}{my latex preset}
This content is cached $\delta$.    
\end{CacheMe}
% And configure them at will
\begin{CacheMe}{my latex preset, set placeholder={__MY_COLOR__}{green}, set my angle=-45}
This content is cached $\delta$.    
\end{CacheMe}
\end{codeexample}
\end{pgfmanualentry}


\subsubsection{Options to configure the template}


\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set template=\marg{content template}\@nil
  \makeatother%
  \pgfmanualbody
  Style that alias to |set placeholder={__ROBEXT_TEMPLATE__}{#1}|, in order to define the placeholder that will hold the template of the final file.
\end{pgfmanualentry}

\subsubsection{Options to configure the compilation command}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set compilation command=\marg{compilation command}\@nil
  \makeatother%
  \pgfmanualbody
  Style that alias to |set placeholder={__ROBEXT_COMPILATION_COMMAND__}{#1}|, in order to define the placeholder that will hold the compilation command.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/add argument to compilation command=\marg{argument}\@nil
  \extractkey/robExt/add arguments to compilation command=\marg{argument}\@nil
  \makeatother%
  \pgfmanualbody
  |add argument to compilation command| is a style that alias to:\\
  |set placeholder={__ROBEXT_COMPILATION_COMMAND__}{__ROBEXT_COMPILATION_COMMAND__ "#1"}|
  in order to add an argument to the compilation command. |add arguments to compilation command| (note the |s|) accepts multiple arguments separated by a comma.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/add key value argument to compilation command=\marg{key=value}\@nil
  \makeatother%
  \pgfmanualbody
  Adds to the command line two arguments |key| and |value|. This is a way to quickly pass arguments to a script: the script just needs to loop over the arguments and consider the odd elements as keys and the next elements as the value. Another option is to insert some placeholders directly in the script.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/add key and file argument to compilation command=\marg{key=filename}\@nil
  \makeatother%
  \pgfmanualbody
  |filename| is the path to a file in the root folder. This adds, as:\\
  |add key value argument to compilation command|\\
  two arguments, where the first argument is the key, but this time the second argument is the path of |filename| relative to the cache folder (useful since scripts run from this folder). Moreover, it automatically ensures that when |filename| changes, the file gets recompiled. Note that contrary to some other commands, this does not copy the file in the cache, which is practical notably for large files like videos.
\end{pgfmanualentry}

\subsubsection{Options to configure the inclusion command}

The inclusion command is the command that is run to include the cached file back in the pdf (e.g. based on |\includegraphics|). We describe now how to configure this command.

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/custom include command advanced=\marg{include command}\@nil
  \makeatother%
  \pgfmanualbody
  Sets the command to run to include the compiled file. You can use:\\
  |\robExtAddPrefixPathAndName{\robExtFinalHash.pdf}|\\
  in order to get the path of the compiled pdf file. Note that we recommend rather to use |custom include command| that automatically checks if the file compiled correctly and that load the |*-out.tex| file if it exists (useful to pass information back to the pdf).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/custom include command=\marg{include command}\@nil
  \makeatother%
  \pgfmanualbody
  Sets the command to run to include the compiled file, after checking if the file has been correctly compiled and loading |*-out.tex| (useful to pass information back to the pdf).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/do not include\@nil
  \makeatother%
  \pgfmanualbody
  Do not include anything. Useful if you only want to compile the file but use it later.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/enable manual mode\@nil
  \extractkey/robExt/disable manual mode\@nil
  \makeatother%
  \pgfmanualbody
  If you do or do not want to ask latex to run the compilation commands itself (for instance for security
  reasons), you can use these commands and run the command manually later:
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/include graphics args\@nil
  \makeatother%
  \pgfmanualbody
  By default, the include commands runs |\includegraphics| on the pdf, and possibly raises it if needed. You can customize the arguments passed to |\includegraphics| here.
\end{pgfmanualentry}

\subsubsection{Configuration of the cache}

If needed, you can configure the cache:

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set filename prefix=\marg{prefix}\@nil
  \makeatother%
  \pgfmanualbody
  By default, the files in the cache starts with |robExt-|. If needed you can change this here, or by manually defining |\def\robExtPrefixFilename{yourPrefix-}|.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/set subfolder and way back=\marg{cache folder}\marg{path to project from cache}\@nil
  \makeatother%
  \pgfmanualbody
  By default, the cache is located in |robustExternalize/|, using:\\
  |set subfolder and way back={robustExternalize/}{../},|\\
  You can customize it the way you want, just be make sure that going to the second arguments after going to the first argument leads you back to the original position.
\end{pgfmanualentry}

\subsubsection{Customize or disable externalization}

You might want (sometimes or always) to disable externalization:

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/disable externalization\@nil
  \extractkey/robExt/enable externalization\@nil
  \makeatother%
  \pgfmanualbody
  Enable or disable externalization. \textbf{TODO: NOTE THAT THIS HAS NOT YET BEEN TESTED AND IS LIKELY BROKEN}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/command if no externalization\@nil
  \makeatother%
  \pgfmanualbody
  You can easily change the command to run if externalization is disabled using by setting the code of this key. By default, it is configured as:\\
  |command if no externalization/.code={\evalPlaceholder{__ROBEXT_MAIN_CONTENT__}}|
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter%
  \def\extrakeytext{style, }
  \extractkey/robExt/execute after each externalization\@nil
  \extractkey/robExt/execute before each externalization\@nil
  \makeatother%
  \pgfmanualbody
  By doing |execute after each externalization={some code}|, you will run some code after the externalization. This might be practical for instance to update a counter (e.g. the number of pages\dots) based on the result of the compiled file.
\end{pgfmanualentry}

\subsubsection{Pass compiled file to another template}

If your template depends on the result of a previous template, you can set a placeholder using |name output with ext|, but this is likely not working yet.

\textbf{TODO: test, need to have global placeholders, or at least pass the information pass the file.}

\subsection{List of special placeholders and presets}\label{sec:placeholders}

This library defines a number of pre-existing placeholders, or placeholders playing a special role. We list them in this section. All placeholders created by this library start with |__ROBEXT_|. Note that you can list the predefined placeholders using |\printAllPlaceholdersExceptDefaults| (note that some other placeholders might be created directly in the style set right before the command, and may not appear in this list if you call it before setting the style).

\subsubsection{Generic placeholders}

We define two special placeholders that should be defined by the user (possibly indirectly, using presets offered by this library):
\begin{itemize}
\item |__ROBEXT_TEMPLATE__| is a placeholder that should contain the code of the file to compile.
\item |__ROBEXT_MAIN_CONTENT__|: is a placeholder that might be used inside |__ROBEXT_TEMPLATE__| and that contains the content that the user is expected to type inside the document. For instance, this might be a tikz picture without all the surrounding environment and document, a python function without the import etc. This will be automatically set by TODO: WRITE THE NAME OF THE CORRESPONDING ENVIRONMENTS HERE.
\item |__ROBEXT_COMPILATION_COMMAND__| contains the compilation command to run to compile the file (assuming we are in the cache folder).
\end{itemize}

We also provide a number of predefined placeholders in order to get the name of the source file etc... Note that most of these placeholders are defined (and/or expanded inplace) late during the compilation stage as one needs first to obtain the hash of the file, and therefore all dependencies, the content of the template etc.
\begin{itemize}
\item |__ROBEXT_SOURCE_FILE__| contains the path of the file to compile (containing the content of |__ROBEXT_TEMPLATE__|) like |robExt-somehash.tex|, relative to the cache folder (since we always go to this folder before doing any action, you most likely want to use this directly in the compilation command).
\item |__ROBEXT_OUTPUT_PDF__| contains the path of the pdf file produced after the compilation command relative to the cache folder (like |robExt-somehash.pdf|). Even if you do not plan to output a pdf file, you should still create that file at the end of the compilation so that this library can know whether the compilation succeeded. 
\item |__ROBEXT_OUTPUT_PREFIX__| contains the prefix that all newly created file should follow, like |robExt-somehash|. If you want to create additional files (e.g. a picture, a video, a console output etc...) make sure to make it start with this string. It will not only help to ensure purity, but it also allows us to garbage collect useless files easily.
\item |__ROBEXT_WAY_BACK__| contains the path to go back to the main project from the cache folder, like |../| (internally it is equals to the expanded value of |\robExtPrefixPathWayBack|).
\item |__ROBEXT_CACHE_FOLDER__| contains the path to the cache folder. Since most commands are run from the cache folder, this should not be really useful to the user.
\item |__ROBEXT_FINAL_COMPILATION_COMMAND__| adds a prefix to |__ROBEXT_COMPILATION_COMMAND__| in order to first go to the cache folder. This is used internally but we do not expect the user of this library to need it.
\end{itemize}

We can check xxxxx

\subsubsection{Placeholders related to \LaTeX{}}
Some placeholders are reserved only when dealing with \LaTeX{} code:
\begin{itemize}
\item |__ROBEXT_LATEX__| is the main entrypoint, containing all the latex template. It internally calls other placeholders listed below.
\item |__ROBEXT_LATEX_OPTIONS__|: contains the options to compile the document, like |a4paper|. Empty by default.
\item |__ROBEXT_DOCUMENT_CLASS__|: contains the class of the document. Defaults to |standalone|.
\item |__ROBEXT_PREAMBULE__|: contains the preambule. Is empty by default.
\item |__ROBEXT_MAIN_CONTENT_WRAPPED__|: content inside the |document| environment. It will wrap the actual content typed by the user |__ROBEXT_MAIN_CONTENT__| around a box to compute its depth. If you do not want this behavior, you can set |__ROBEXT_MAIN_CONTENT_WRAPPED__| to be equal to |__ROBEXT_MAIN_CONTENT__|. It calls internally |__ROBEXT_CREATE_OUT_FILE__| and |__ROBEXT_WRITE_DEPTH_TO_OUT_FILE__| to do this computation.
\item |__ROBEXT_CREATE_OUT_FILE__| creates a new file called |\jobname-out.tex| and open it in the handle called |\writeRobExt|
\item |__ROBEXT_WRITE_DEPTH_TO_OUT_FILE__| writes the height, depth and width of the box |\boxRobExt| into the filed opened in |\writeRobExt|.
\item |__ROBEXT_COMPILATION_COMMAND_LATEX__| is the command used to compile a \LaTeX{} document. It uses internally other placeholders:
\item |__ROBEXT_LATEX_ENGINE__| is the engine used to compile the document (defaults to |pdflatex|)
\item |__ROBEXT_COMPILATION_COMMAND_OPTIONS__| contains the options used to compile the document (defaults to |-shell-escape -halt-on-error|)
\end{itemize}


\end{document}
% Local Variables:
% TeX-command-extra-options: "-shell-escape -halt-on-error"
% End: